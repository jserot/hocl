%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                                     %%
%%                This file is part of the HoCL Compiler distribution                  %%
%%                                                                                     %%
%%      Copyright 2019 Jocelyn SEROT (jocelyn.serot@uca.fr).  All rights reserved.     %%
%%         This file is distributed under the terms of the MIT Library License         %%
%%                                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Core Abstract Syntax}
\label{chap:abssyn}

\newcommand{\tm}[1]{\mathtt{#1}}
\newcommand{\ut}[1]{\emph{#1}}
\newcommand{\cat}[1]{\text{#1}}

This chapter gives the abstract syntax of a simplified version of the \hocl language.  This syntax
will be used in chapters~\ref{chap:typing} and \ref{chap:static} to formalize the typing and static
semantics of the language. The main omissions, compared to the ``full'' \hocl language concern
the annotations on IO ports,
the description of opaque actors,
list patterns and constructors,
and mutually recursive definitions.

% The omitted features are either classical, and
% hence not specific to \caph\footnote{This is the case for global type definitions for example, which
%   are handled exactly like in all other ML-like languages.}, or just introduce too
% much technical details in the definition of the typing rules and static and dynamic
% semantics\footnote{In Chap.~\ref{chap:typing}, \ref{chap:static} and \ref{chap:dynamic-semantics}
%   resp.} without interfering with the global soundness of the formal system.

%\bigskip
\clearpage
$  \begin{array}{lll}
    \ut{program} ::= & \tm{program}~\ut{typedecl}^*~\ut{valdecl}^*~\ut{nodedecl}^+~\ut{graphdecl}^+ & \\
    \\
    \ut{typedecl}  ::= & \tm{type}~\cat{id} & \\
     \\
    \ut{nodedecl}  ::= & \tm{node}~\cat{id}~\ut{param}^*~\ut{io}^*~\ut{io}^*~\ut{nodeimpl} &\\
    \\
    \ut{param} ::= &  \cat{id}~\tm{:}~\ut{tyexpr}~[\tm{=}~\ut{pexp}] & \text{value only for
                                                                        toplevel graph parameters}\\
    \\
    \ut{io} ::= &  \cat{id}~\tm{:}~\ut{tyexpr} & \\
    \\
    \ut{nodeimpl}  ::= &  ~|\ \tm{actor} & \\
                       &  ~|\ \tm{graph}~\ut{graphdefn} & \\
    \\
    \ut{graphdecl}  ::= & \tm{graph}~\cat{id}~\ut{param}^*~\ut{io}^*~\ut{io}^*~\ut{graphdefn} &
                                                                                                \text{name,
                                                                                                params,
     ins, outs, defn}\\
    \\
    \ut{graphdefn}  ::= & ~|\ \tm{gsd}~\ut{gwire}^*~\ut{gnode}^* & \text{structural definition} \\
                        & ~|\ \tm{gfd}~\ut{valdecl}^* & \text{functional definition}  \\
    \\
    \ut{gwire}  ::= & \tm{wire}~\cat{id}~\tm{:}~\ut{tyexpr} & \text{name, type}\\
    \\
    \ut{gnode}  ::= & \tm{node}~\cat{id}~\tm{:}~\cat{id}~\ut{pexp}^*~\cat{id}^*~\cat{id}^* & \text{name, model, params, ins, outs} \\
    \\
    \ut{valdecl}    ::= & \tm{val}~\ut{recflag}~\ut{pattern}~\tm{=}~\ut{expr} & \\
    \\
%    \ut{binding} ::= & \ut{pattern}~\tm{=}~\ut{expr} & \\
\end{array}$

$  \begin{array}{lll}
    \ut{pattern}  ::= & ~|\   \cat{var} & \\
                      & ~|\   \tm{(}~\ut{pattern}^*_,~\tm{)} & (\ut{pat}_1,\ldots,\ut{pat}_n) \\
                      & ~|\   \tm{()} & \text{unit} \\
                      & ~|\   \tm{\_} & \text{ignore}\\
    \\
    \ut{expr}  ::= & ~|\   \cat{var} & \text{for denoting graph constructs} \\
                 & ~|\   \cat{int} ~|~ \cat{bool} & \\
                 & ~|\   \tm{()} & \\
                 & ~|\   \tm{(}~\ut{expr}^+_,~\tm{)} & \text{tuples} \\
                 & ~|\   \ut{expr}~~\ut{pexp}^+ & f\ <\text{params}> \\
                      & ~|\   \ut{expr}_1~~\ut{expr}_2 & f\ \text{arg} \\
                 & ~|\   \tm{fun}~\ut{pattern}~\tm{\rightarrow}~\ut{expr} & \\
                 & ~|\   \tm{let}~[\tm{rec}]~\ut{pattern}~\tm{=}~\ut{expr}~\tm{in}~\ut{expr} & \\
%                 & ~|\   \tm{let}~\ut{recflag}~\ut{binding}^+~\tm{in}~\ut{expr} & \\
                 & ~|\   \tm{if}~\ut{expr}~\tm{then}~\ut{expr}~\tm{else}~\ut{expr} & \\
    \\
    % \ut{recflag} ::= & \tm{rec} ~|~ \tm{nonrec} \\
    % \\
    \ut{pexp}  ::= & ~|\   \cat{var} & \text{for denoting parameter values}\\
                 & ~|\   \cat{int} ~|~ \cat{bool} & \\
                 & ~|\   \ut{pexp}~\cat{binop}~\ut{pexp} & \text{builtin binary opn (+,*,...)} \\
    \\
    \ut{tyexpr} ::= &  \cat{id} & \text{nullary type ctor} \\
                    % & ~|\ \ut{tyexpr}_1 \times \ldots \times \ut{tyexpr}_n & n\geq 1 \\
                    % & ~|\ \ut{tyexpr}_1 \rightarrow \ut{tyexpr}_2 & \\
  \end{array} $

\todo{nil/cons npatterns; nil, cons, and match expr}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hocl-lrm"
%%% End: 
