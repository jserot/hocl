%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                                     %%
%%                This file is part of the CAPH Compiler distribution                  %%
%%                            http:%/caph.univ-bpclermont.fr                           %%
%%                                                                                     %%
%%                                  Jocelyn SEROT                                      %%
%%                         Jocelyn.Serot@univ-bpclermont.fr                            %%
%%                                                                                     %%
%%         Copyright 2011-2018 Jocelyn SEROT.  All rights reserved.                    %%
%%  This file is distributed under the terms of the GNU Library General Public License %%
%%      with the special exception on linking described in file ..%LICENSE.            %%
%%                                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Typing}
\label{chap:typing}

\newcommand{\sy}[1]{\mathbf{#1}}
\newcommand{\sem}[1]{\mathsf{#1}}

\todo{type abbrevs}

This section gives the formal typing rules for the so-called \emph{core} \hocl language defined in
Chap.~\ref{chap:abssyn}. 

\medskip
The type language is fairly standard. A type $\tau$ is either~:
\begin{itemize}
\item a type variable $\alpha$
\item a constructed type $\chi\ \tau_1 \ldots \tau_n$, 
\item a functional type $\tau_1 \rightarrow \tau_2$,
\item a product type $\tau_1 \times \ldots \times \tau_n$,
\end{itemize}

\medskip
Typing occurs in the context of a \emph{typing environment} consisting of :
\begin{itemize}
\item a type environment $\TE$, recording type constructors,
\item a variable environment $\VE$, mapping identifiers to types\footnote{More precisely, to \emph{type
      schemes} $\sigma=\forall \alpha.\ \tau$; but, for simplicity, we do not distinguish types from type schemes
      in this presentation, \emph{i.e.} the instanciation of a type scheme into a type and the
      generalisation of a (polymorphic) type into a type scheme are left implicit in the rules given
      above. The corresponding definitions are completely standard.}
\end{itemize}

\medskip
The initial type environment $\TE_0$ records the type of the \emph{builtin} type constructors~:

$\begin{array}{lcl}
\TE_0 & = & \{ \txt{int}\mapsto \sem{Int}, \txt{bool}\mapsto \sem{Bool}, \ldots \}
\end{array}$

% $\begin{array}{lcl}
% \TE_0.tycons & = & [ \sy{int}\mapsto \sem{Int}, \sy{bool}\mapsto \sem{Bool}, \\
% %             &   &   \sy{array}\mapsto \alpha \rightarrow \sem{Array}~\alpha, \\
%              &   &   \sy{dc}\mapsto \alpha \rightarrow \sem{Dc}~\alpha ] \\
% \TE_0.ctors & = & [ \sy{0} \mapsto \sem{Int}, \sy{1} \mapsto \sem{Int}, \ldots, \\
%             &   & \sy{true} \mapsto \sem{Bool}, \sy{false} \mapsto \sem{Bool} \\
%             &   & \sy{SoS} \mapsto \sem{Dc}~\alpha, \sy{EoS} \mapsto \sem{Dc}~\alpha, \sy{Data} \mapsto \alpha \rightarrow \sem{Dc}~\alpha ] \\
% \end{array}$

\medskip
The initial variable environment $\VE_0$ contains the types of the builtin
primitives.

$\begin{array}{lcl}
\VE_0 & = & \{ \sy{+} : \sem{Int} \times \sem{Int} \rightarrow \sem{Int}, \sy{=} : \sem{Int} \times
            \sem{Int} \rightarrow \sem{Bool}, \ldots \} \\
\end{array}$

\section{Notations}
\label{sec:typing-notations}

Both type and variable \emph{environments} are viewed as partial maps (from identifiers to types and
from type constructors to types resp.). If $E$ is an environment, the domain of $E$ is denoted by
$\text{dom}(E)$.  The empty environment is written $\emptyenv$.  $[x \mapsto y]$ denotes the
singleton environment mapping $x$ to $y$.  We note $E(x)$ the result of applying the underlying map
to $x$ (for ex. if $E$ is $[x \mapsto y]$ then $E(x)=y$) and $E[x \mapsto y]$ the environment that
maps $x$ to $y$ and behaves like $E$ otherwise. $E \oplus E'$ denotes the environment obtained by
adding the mappings of $E'$ to those of $E$. If $E$ and $E'$ are not disjoints, then the mappings of
$E$ are ``shadowed'' by those of $E'$. Given two types $\tau$ and $\tau'$, we will note
$\tau \cong \tau'$ if $\tau$ and $\tau'$ are equal modulo unification\footnote{If $\tau$ and $\tau'$
  are monomorphic, this is structural equality.}. Finally, given two typing environments $\VE$ and
$\VE'$, we will note $\VE \subset \VE'$ \emph{iff}
$\forall x \in \text{dom}(\VE) \cap \text{dom}(\VE'),\ \VE(x) \cong \VE'(x)$, \emph{i.e.} \emph{iff}
for each symbol occuring both in $\VE$ and $\VE'$, the related types are equals modulo
unification\footnote{This relation will be used to check that the types \emph{inferred} when typing graph or node
definitions match the types \emph{declared} in their interface).}. 

% We will also use a specialized version of the $\oplus$ merging
% operator, denoted $\replace$, for which shadowing is replaced by type unification: if $x$ appears
% both in $E$ and $E'$, and maps respectively to $\sigma$ and $\sigma'$, then it will map to
% $\text{unify}_E(\sigma,\sigma')$ in $E \replace E'$
% (this simplifies the description of the semantics of definitions for outputs).
% $E \ominus E'$ denotes the environment obtained by removing any mapping $\lbrace x \mapsto y \rbrace$ for which $x
% \in dom(E')$ from E.

% When an environment $E$ is composed of several sub-environments $E'$,$E''$, \ldots, we note $E = \{
% E', E'', \ldots \}$ and use the dot notation to access these sub-environments (ex: $E.E'$).

\medskip
For convenience and readability, we will adhere to the following
naming conventions throughout this chapter :

\begin{center}
\begin{tabular}[c]{c|c}
  \textbf{Meta-variable} & \textbf{Meaning} \\ \hline
  $\TE$         & Type environment \\ 
  $\VE$         & Variable environment \\ 
  $ty$          & Type expression \\ 
  $\tau$        & Type or type scheme\\ 
%  $\sigma$      & Type scheme \\ 
  $\alpha$      & Type variable \\ 
   $\chi$           & Type constructor \\ 
%   $c$           & Value constructor \\ 
   $\text{id}$    & Identifier \\ 
   $\emph{pat}$   & Pattern \\ 
  $\emph{expr}$   & Graph expression \\ 
   $\emph{pexp}$   & Param expression
\end{tabular}
\end{center}

\medskip
Syntactical terminal symbols are written in $\mathbf{bold}$. Non terminals in $\emph{italic}$. Types
values are written in $\mathsf{serif}$.

% \newpage
\section{Typing rules}
\label{sec:typing-rules}

\subsection{Programs}
\label{sec:typing-progr}

\ruleheader{\TE,\VE \vdash \text{Program} \gives \VE_v,\VE_n,\VE_g}

\infrule[Program]
{ \TE_0 \vdash \emtxt{tydecls} \gives \TE \\
  \TE_0 \oplus \TE, \VE_0 \vdash \emtxt{valdecls} \gives \VE_v \\
  \andalso \TE_0 \oplus \TE, \VE_0 \oplus \VE_v \vdash \emtxt{nodedecls} \gives \VE_n \\
  \andalso \TE_0 \oplus \TE, \VE_0 \oplus \VE_v \oplus \VE_n \vdash \emtxt{graphdecls} \gives \VE_g}
{\TE_0, \VE_0 \vdash \sy{program} ~\emtxt{tydecls} ~\emtxt{valdecls}
  ~\emtxt{nodedecls} ~\emtxt{graphdecls} \gives \VE_v,\VE_n,\VE_g}

Value, node and graph declarations are typed in en type environment augmented by the
The result of the typing phase is a triplet of variable environments respectively recording the
types of declared values, node models and graphs.

\subsection{Type declarations}
\label{sec:typing-type-decls}

\ruleheader{\TE~\vdash \text{TyDecls} \gives \TE'}

\infrule[TyDecls]
{\forallin{i}{1}{n},~~ \TE~\vdash \emtxt{tydecl}_i \gives \TE_i}
{\TE \vdash \emtxt{tydecl}_1~\ldots~\emtxt{tydecl}_n \gives \C{i=1}{n}{\TE_i}}

\ruleheader{\TE~\vdash \text{TyDecl} \gives \TE'}

\infrule[TyDecl]
{}
{\TE~ \vdash \sy{type}~\txt{id} \gives [\txt{id} \mapsto \sem{Id}]}

The current version only supports \emph{opaque} type declarations. In the previous rule, $\sem{Id}$
is the type constructor corresponding to the identifier $\txt{id}$.

% \infrule[TyDecl]
% { \TE~\vdash \emtxt{ty} \gives \tau }
% {\TE~ \vdash \mathtt{type}~\txt{id}~\mathtt{=}~\emtxt{ty} \gives [\txt{id} \mapsto \tau]}

\subsection{Value declarations}
\label{sec:typing-value-decls}

\ruleheader{\TE, \VE~\vdash \text{ValDecls} \gives \VE'}

\infrule[ValDecls]
{\forallin{i}{1}{n},~~ \TE,\VE_{i-1}~\vdash \emtxt{valdecl}_i \gives \VE_i,~~ \VE_0=\VE}
{\TE, \VE~ \vdash \emtxt{valdecl}_1~\ldots~\emtxt{valdecl}_n \gives {\VE_n}}

% \infrule[ValDecl]
% {\forallin{i}{1}{n},~~ \TE,\VE \vdash \emtxt{nbind} \gives \VE_i \andalso \VE'=\C{i=1}{n}{\VE_i}}
% {\TE, \VE \vdash \mathbf{val}~ \mathbf{nonrec}~ \emtxt{pat}~ \mathbf{=}~ \emtxt{exprr} \gives \VE \oplus \VE'}

% \infrule[NetRecDecl]
% {\forallin{i}{1}{n},~~ \TE,\VE \oplus \VE' \vdash \emtxt{nbind} \gives \VE_i \andalso \VE'=\C{i=1}{n}{\VE_i}}
% {\TE, \VE \vdash \mathbf{net}~ \mathbf{rec}~ \tuplen{nbind} \gives \VE \oplus \VE'}

\ruleheader{\TE, \VE~ \vdash \text{ValDecl} \gives \VE'}

\infrule[ValDecl]
{\TE, \VE \vdash \emtxt{expr} \gives \tau \andalso \vdash_p \emtxt{pat},\tau \gives \VE'}
{\TE, \VE \vdash \mathbf{val}~ \emtxt{pat}~ \mathbf{=}~ \emtxt{expr}~ \gives \VE'}

\infrule[ValRecDecl]
{\TE, \VE \oplus \VE' \vdash \emtxt{expr} \gives \tau \andalso \vdash_p \emtxt{pat},\tau \gives \VE'}
{\TE, \VE \vdash \mathbf{val}~ \mathbf{rec}~ \emtxt{pat}~ \mathbf{=}~ \emtxt{expr}~ \gives \VE'}

\subsubsection{Patterns}
\label{sec:typing-patterns}

\ruleheader{\vdash_p \text{Pattern},\tau \gives \VE}

\infrule[PatVar]
{}
{\vdash_p \txt{id}, \tau \gives [\txt{id} \mapsto \tau]}

\infrule[PatTuple]
{\forallin{i}{1}{n}, ~~\vdash_p \emtxt{pat}~_i, \tau_i \gives \VE_i}
{\vdash_p \leftp \emtxt{pat}~_1, \ldots \emtxt{pat}~_n \rightp, \tau_1 \times \ldots \times \tau_n \gives \C{i=1}{n}{\VE_i}}

\infrule[PatUnit]
{}
{\vdash_p \mathbf{()}, \mathsf{Unit} \gives \emptyenv}

\infrule[PatIgnore]
{}
{\vdash_p \mathbf{\_}, \tau \gives \emptyenv}

% \infrule[Pat Cons]
% {\vdash_p \emtxt{pat}_1, \tau \gives \VE \andalso \vdash_p \emtxt{pat}_2,\mathsf{List}~{\tau} \gives \VE'}
% {\vdash_p \mathbf{cons}(\emtxt{pat}_1,\emtxt{pat}_2), \mathsf{List}~{\tau} \gives \VE \oplus \VE'}

% \infrule[Pat Nil]
% {}
% {\vdash_p \mathbf{nil}, \mathsf{List}~{\alpha} \gives \emptyenv}

where 

\infax{\vdash_p \emtxt{pat}, \tau \gives \VE}

means that declaring \emph{pat} with type $\tau$ creates the variable environment $\VE$.

\subsubsection{Expressions}
\label{sec:typing-graph-expressions}

\ruleheader{\TE, \VE~ \vdash \text{Expr} \gives \tau}

\infrule[EVar]
{\VE(id) = \tau}
{\TE,\VE \vdash \txt{id} \gives \tau}

\infrule[EConst]
{}
{\TE,\VE \vdash \txt{int}/\txt{bool} \gives \mathsf{Int}/\mathsf{Bool}}

\infrule[EUnit]
{}
{\TE,\VE \vdash \mathbf{()} \gives \mathsf{Unit}}

\infrule[ETuple]
{\forallin{i}{1}{n}, ~~\TE,\VE \vdash ~\emtxt{expr}_i \gives  \tau_i}
{\TE,\VE \vdash \mathbf{(} \emtxt{expr}_1 \mathbf{,} ~\ldots ~\emtxt{expr}_n \mathbf{)} \gives  \tau_1 \times \ldots \times \tau_n}

\infrule[EPApp] {\TE,\VE \vdash \emtxt{expr} \gives \tau \rightarrow \tau' \rightarrow \tau''
  \andalso \TE,\VE \vdash \emtxt{pexps} \gives \tau} {\TE,\VE \vdash \emtxt{expr} ~\emtxt{pexps}
  \gives \tau' \rightarrow \tau''}

\infrule[EApp]
{\TE,\VE \vdash \emtxt{expr}_1 \gives  \tau \rightarrow \tau' \andalso \TE,\VE \vdash \emtxt{expr}_2 \gives \tau}
{\TE,\VE \vdash \emtxt{expr}_1 ~\emtxt{expr}_2 \gives  \tau'}

\infrule[EFun]
{\vdash_p \emtxt{pat}~, \tau \gives \VE' \andalso \TE, \VE \oplus \VE' \vdash \emtxt{expr} \gives \tau'}
{\TE,\VE \vdash \mathbf{fun}~ \emtxt{pat}~ \rightarrow \emtxt{expr} \gives \tau \rightarrow \tau'}

\infrule[ELet]
{\vdash_p \emtxt{pat}~, \tau' \gives \VE' \andalso \TE,\VE \vdash \emtxt{expr}_2 \gives  \tau' \andalso \VE \oplus \VE' \vdash \emtxt{expr}_1 \gives  \tau}
{\TE,\VE \vdash \mathbf{let}~ \emtxt{pat}~ \bftxt{=} \emtxt{expr}_2~ \mathbf{in}~ \emtxt{expr}_1 \gives  \tau}

\infrule[ELetRec]
{\vdash_p \emtxt{pat}~, \tau' \gives \VE' \andalso \TE, \VE \oplus \VE' \vdash \emtxt{expr}_2 \gives  \tau'
  \andalso \VE \oplus \VE' \vdash \emtxt{expr}_1 \gives  \tau}
{\TE,\VE \vdash \mathbf{let}~ \mathbf{rec}~ \emtxt{pat}~ \bftxt{=} \emtxt{expr}_2~ \mathbf{in}~ \emtxt{expr}_1 \gives  \tau}

\infrule[EIf]
{\TE,\VE \vdash \emtxt{expr} \gives \mathsf{Bool} \andalso \TE,\VE \vdash \emtxt{expr}_1 \gives \tau \andalso \TE,\VE \vdash \emtxt{expr}_2 \gives \tau}
{\VE \vdash \mathbf{if}~\emtxt{expr}~\mathbf{then}~\emtxt{expr}_1~\mathbf{else}~\emtxt{expr}_2 \gives \tau}

% \infrule[EMatch]
% {\VE \vdash \emtxt{expr}\gives\tau_1 \andalso \forallin{i}{1}{n},~~\vdash_p \emtxt{pat}~_i,\tau_1 \gives \VE_i
%   \andalso \VE
%   \oplus \VE_i \vdash \emtxt{expr}_i \gives \tau_2}
% {\VE \vdash \mathbf{match}~ \emtxt{expr} ~\mathbf{with}~ (\emtxt{pat}~_1 \rightarrow \emtxt{expr}_1) \ldots (\emtxt{pat}~_n \rightarrow \emtxt{expr}_n) \gives \tau_2}

% \infrule[ECons]
% {\VE \vdash \emtxt{expr}~_1 \gives \tau \andalso \VE \vdash \emtxt{expr}~_2 \gives \mathsf{List}~\tau}
% {\VE \vdash \mathbf{cons}(\emtxt{expr}_1,\emtxt{expr}_2) \gives  \mathsf{List}~\tau}

% \infrule[ENil]
% {}
% {\VE \vdash \mathbf{()} \gives \mathsf{List}~\alpha}

\subsubsection{Param expressions}
\label{sec:typing-param-expressions}

\ruleheader{\TE, \VE~ \vdash \text{PExps} \gives \tau}

\infrule[PExps]
{\forallin{i}{1}{n}, ~~\TE,\VE \vdash ~\emtxt{pexp}_i \gives \tau_i}
{\TE,\VE \vdash \emtxt{pexp}_1 \mathbf{,} ~\ldots ~\emtxt{pexp}_n \gives \tau_1 \times \ldots \times \tau_n}

\ruleheader{\TE, \VE~ \vdash \text{PExp} \gives \tau}

\infrule[PVar]
{\VE(id) = \tau}
{\TE,\VE \vdash \txt{id} \gives \tau}

\infrule[PConst]
{}
{\TE,\VE \vdash \txt{int}/\txt{bool} \gives \mathsf{Int}/\mathsf{Bool}}

\infrule[PBinop]
{\VE(op) = \tau \times \tau' \rightarrow \tau'' \\
  \andalso \TE,\VE \vdash \emtxt{pexp}_1 \gives \tau \\
  \andalso \TE,\VE \vdash \emtxt{pexp}_2 \gives \tau'}
{\TE,\VE \vdash \emtxt{pexp}_1 ~\cat{binop} ~\emtxt{pexp}_2 \gives \tau''}

\subsection{Node declarations}
\label{sec:typing-node-models}

\ruleheader{\TE, \VE ~\vdash \text{NodeDecls} \gives \VE'}

\infrule[NodeDecls]
{\forallin{i}{1}{n},~~ \TE,\VE_{i-1}~\vdash \emtxt{nodedecl}_i \gives \VE_i,~~ \VE_0=\VE}
{\TE,\VE~ \vdash \emtxt{nodedecl}_1~\ldots~\emtxt{nodedecl}_n \gives \C{i=1}{n}{\VE_i}}

\ruleheader{\TE, \VE ~\vdash \text{NodeDecl} \gives \VE'}

\infrule[NodeDecl1]
{          \emtxt{params} \not = \emptyset \\
           \TE \vdash \emtxt{params} \gives \tau_p,\VE_p \\
  % \andalso \TE,\VE \oplus \VE_p \vdash \emtxt{ins} \gives \tau_i,\VE_i \\
  % \andalso \TE,\VE \oplus \VE_p \vdash \emtxt{outs} \gives \tau_o,\VE_o \\
  % \andalso \TE,\VE \oplus \VE_p \oplus \VE_i \vdash \emtxt{nodeimpl} \gives \VE'_o \\
  % Adding VE_p may be required when typing dependent types 
  \andalso \TE \vdash \emtxt{ins} \gives \tau_i,\VE_i \\
  \andalso \TE \vdash \emtxt{outs} \gives \tau_o,\VE_o \\
  \andalso \TE,\VE \oplus \VE_p \oplus \VE_i \vdash \emtxt{nodeimpl} \gives \VE'_o \\
  \andalso \VE'_o \subset \VE_o 
}
{\TE,\VE~ \vdash
  \mathbf{node}~\txt{id}~\emtxt{params}~\emtxt{ins}~\emtxt{outs}~\emtxt{nodeimpl}
  \gives [\txt{id} \mapsto \tau_p \rightarrow \tau_i \rightarrow \tau_o]}

\infrule[NodeDecl2]
{          \emtxt{params} = \emptyset \\
  \andalso \TE \vdash \emtxt{ins} \gives \tau_i,\VE_i \\
  \andalso \TE \vdash \emtxt{outs} \gives \tau_o,\VE_o \\
  % \andalso \TE,\VE \vdash \emtxt{ins} \gives \tau_i,\VE_i \\
  % \andalso \TE,\VE \vdash \emtxt{outs} \gives \tau_o,\VE_o \\
  % Adding VE_p may be required when typing dependent types 
  \andalso \TE,\VE \oplus \VE_i \vdash \emtxt{nodeimpl} \gives \VE'_o \\
  \andalso \VE'_o \subset \VE_o 
}
{\TE,\VE~ \vdash
  \mathbf{node}~\txt{id}~\emtxt{params}~\emtxt{ins}~\emtxt{outs}~\emtxt{nodeimpl}
  \gives [\txt{id} \mapsto \tau_i \rightarrow \tau_o]}

The type assigned to a node only depends on its interface (parameters, inputs and outputs).
A node \texttt{n} declared as

\begin{center}
$\mathtt{node}~n~\mathtt{param}(p_1:t_1,\ldots,p_k:t_k)~\mathtt{in}~(i_1:t'_1,\ldots,i_m:t'_m)~\mathtt{out}~(o_1:t''_1,\ldots,o_n:t''_n)$
\end{center}

\medskip
will be assigned type

\medskip
\begin{center}
$\typaram{t_1}\times\ldots\times \typaram{t_k} \rightarrow \tywire{t'_1}\times\ldots\times
  \tywire{t'_m} \rightarrow \tywire{t''_1}\times\ldots\times \tywire{t''_n}$
\end{center}

\noindent
where $\mathsf{param}$ and $\mathsf{wire}$ are predefined type constructors, used to distinguish
values denoting bound to node parameters and node IOs respectively.

\medskip
Whereas a node \texttt{n} declared as

\begin{center}
$\mathtt{node}~n~\mathtt{in}~(i_1:t'_1,\ldots,i_m:t'_m)~\mathtt{out}~(o_1:t''_1,\ldots,o_n:t''_n)$
\end{center}

will be assigned type

\begin{center}
$\tywire{t'_1}\times\ldots\times \tywire{t'_m} \rightarrow \tywire{t''_1}\times\ldots\times \tywire{t''_n}$
\end{center}

\subsection{Node or graph parameters}
\label{sec:typing-node-or-graph-params}

\ruleheader{\TE,\VE~\vdash \text{Params} \gives \tau,\VE'}

\infrule[Params]
{\forallin{i}{1}{n},~~ \TE,\VE~\vdash \emtxt{param}_i \gives \tau_i,\VE_i}
{\TE,\VE~ \vdash \emtxt{param}_1~\ldots~\emtxt{param}_n \gives \tau_1\times\ldots\times\tau_n,~ \C{i=1}{n}{\VE_i}}

\ruleheader{\TE,\VE~\vdash \text{Param} \gives \tau,\VE'}

\infrule[Param]
{\TE~\vdash \ty \gives \tau \\
\tau' = \typaram{\tau}}
{\TE,\VE~\vdash \txt{id} ~:~ \ty \gives \tau',~ [\txt{id} \mapsto \tau']}

\infrule[ParamWithValue]
{\TE~\vdash \ty \gives \tau \\
 \TE,\VE ~\vdash \emtxt{pexp} \gives \tau' \\
  \tau \cong \tau' \\
  \tau'' = \typaram{\tau}}
{\TE,\VE~\vdash \txt{id} ~:~ \ty ~=~ \emtxt{pexp} \gives \tau'',~ [\txt{id} \mapsto \tau'']}

\subsection{Node or graph IOs}
\label{sec:typing-node-or-graph-ios}

\medskip\ruleheader{\TE~\vdash \text{Ios} \gives \tau,\VE'}

\infrule[Ios]
{\forallin{i}{1}{n},~~ \TE~\vdash \emtxt{io}_i \gives \tau_i, \VE_i}
{\TE~ \vdash \emtxt{io}_1~\ldots~\emtxt{io}_n \gives \tau_1 \times \ldots \times \tau_n,~ \C{i=1}{n}{\VE_i}}

\medskip\ruleheader{\TE~\vdash \text{Io} \gives \tau,\VE'}

\infrule[Io]
{\TE~\vdash \ty \gives \tau \\
\tau' = \tywire{\tau}}
{\TE~\vdash \txt{id} ~:~ \ty \gives \tau',~ [\txt{id} \mapsto \tau']}

\medskip\ruleheader{\TE,\VE~\vdash \text{NodeImpl} \gives \VE'}

\subsection{Node implementation}
\label{sec:typing-node-impl}

\infrule[ActorImpl]
{}
{\TE,\VE~\vdash \mathbf{actor}\gives \emptyenv}

\infrule[GraphImpl]
{\TE,\VE~\vdash \emtxt{graphdefn} \gives \VE'}
{\TE,\VE~\vdash \mathbf{graph}~\emtxt{graphdefn} \gives \VE'}

\subsection{Graph definitions}
\label{sec:typing-graph-definitions}

\medskip\ruleheader{\TE,\VE~\vdash \text{GraphDefn} \gives \VE'}

\infrule[GraphFunDefn]
{\forallin{i}{1}{n},~~ \TE,\VE_{i-1}~\vdash \emtxt{valdecl}_i \gives \VE_i,~~ \VE_0=\VE}
{\TE, \VE~ \vdash \mathbf{gfd}~ \emtxt{valdecl}_1~\ldots~\emtxt{valdecl}_n \gives  \C{i=1}{n}{\VE_i}}

\infrule[GraphStructDefn]
{\TE~\vdash \emtxt{wires} \gives \VE_w \\
 \TE,\VE \oplus \VE_w ~\vdash \emtxt{nodes} \gives \VE_o}
{\TE,\VE~ \vdash \mathbf{gsd}~ \emtxt{wires}~\emtxt{nodes} \gives \VE_o}

\subsubsection{Graph structural definitions}
\label{sec:typing-graph-struct-definitions}

\medskip\ruleheader{\TE~\vdash \text{Wires} \gives \VE'}

\infrule[Wires]
{\forallin{i}{1}{n},~~ \TE~\vdash \emtxt{wire}_i \gives \VE_i}
{\TE~ \vdash \emtxt{wire}_1~\ldots~\emtxt{wire}_n \gives \C{i=1}{n}{\VE_i}}

\medskip\ruleheader{\TE~\vdash \text{Wire} \gives \VE'}

\infrule[Wire]
{\TE~\vdash \ty \gives \tau \\
\tau' = \tywire{\tau}}
{\TE~\vdash \mathbf{wire}~ \txt{id} ~:~ \ty \gives [\txt{id} \mapsto \tau']}

\medskip\ruleheader{\TE,\VE~\vdash \text{Nodes} \gives \VE'}

\infrule[Nodes]
{\forallin{i}{1}{n},~~ \TE,\VE~\vdash \emtxt{node}_i \gives \VE_i}
{\TE,\VE~ \vdash \emtxt{node}_1~\ldots~\emtxt{node}_n \gives \C{i=1}{n}{\VE_i}}

\medskip\ruleheader{\TE,\VE~\vdash \text{Node} \gives \VE'}

\infrule[Node1]
{\emtxt{pvals} \not = \emptyset \\
  \VE(m) = \tau \rightarrow \tau' \rightarrow \tau'' \\
  \TE \vdash \emtxt{pvals} \gives \tau_p \\
  \andalso \TE \vdash \emtxt{ins} \gives \tau_i, \VE_i \\
  \andalso \TE \vdash \emtxt{outs} \gives \tau_o, \VE_o \\
  \andalso \tau_p \cong \tau 
  \andalso \tau_i \cong \tau'
  \andalso \tau_o \cong \tau'' 
}
{\TE,\VE~\vdash \mathbf{node}~\txt{id}~:~\txt{m}~\emtxt{pvals}~\emtxt{ins}~\emtxt{outs} \gives \VE_o}

\infrule[Node2]
{\emtxt{pvals} = \emptyset \\
  \VE(m) = \tau \rightarrow \tau' \\
  \andalso \TE \vdash \emtxt{ins} \gives \tau_i, \VE_i \\
  \andalso \TE \vdash \emtxt{outs} \gives \tau_o, \VE_o \\
  \andalso \tau_i \cong \tau
  \andalso \tau_o \cong \tau' 
}
{\TE,\VE~\vdash \mathbf{node}~\txt{id}~:~\txt{m}~\emtxt{pvals}~\emtxt{ins}~\emtxt{outs} \gives \VE_o}

\subsection{Graph declarations}
\label{sec:typing-graph-decls}

\ruleheader{\TE, \VE ~\vdash \text{GraphDecls} \gives \VE'}

\infrule[GraphDecls]
{\forallin{i}{1}{n},~~ \TE,\VE_{i-1}~\vdash \emtxt{graphdecl}_i \gives \VE_i,~~ \VE_0=\VE}
{\TE,\VE~ \vdash \emtxt{graphdecl}_1~\ldots~\emtxt{graphdecl}_n \gives \C{i=1}{n}{\VE_i}}

\ruleheader{\TE, \VE ~\vdash \text{GraphDecl} \gives \VE'}

\infrule[GraphDecl1]
{\emtxt{params} \not = \emptyset \\
  \TE \vdash \emtxt{params} \gives \tau_p,\VE_p \\
  % \andalso \TE,\VE \oplus \VE_p \vdash \emtxt{ins} \gives \tau_i,\VE_i \\
  % \andalso \TE,\VE \oplus \VE_p \vdash \emtxt{outs} \gives \tau_o,\VE_o \\
  % \andalso \TE,\VE \oplus \VE_p \oplus \VE_i \vdash \emtxt{nodeimpl} \gives \VE'_o \\
  % Adding VE_p may be required when typing dependent types 
  \andalso \TE \vdash \emtxt{ins} \gives \tau_i,\VE_i \\
  \andalso \TE \vdash \emtxt{outs} \gives \tau_o,\VE_o \\
  \andalso \TE,\VE \oplus \VE_p \oplus \VE_i \vdash \emtxt{graphdefn} \gives \VE'_o \\
  \andalso \VE'_o \subset \VE_o 
}
{\TE,\VE~ \vdash
  \mathbf{graph}~\txt{id}~\emtxt{params}~\emtxt{ins}~\emtxt{outs}~\emtxt{graphdefn}
  \gives [\txt{id} \mapsto \tau_p \rightarrow \tau_i \rightarrow \tau_o]}

\infrule[GraphDecl2]
{\emtxt{params} = \emptyset \\
  \andalso \TE \vdash \emtxt{ins} \gives \tau_i,\VE_i \\
  \andalso \TE \vdash \emtxt{outs} \gives \tau_o,\VE_o \\
  \andalso \TE,\VE \oplus \oplus \VE_i \vdash \emtxt{graphdefn} \gives \VE'_o \\
  \andalso \VE'_o \subset \VE_o 
}
{\TE,\VE~ \vdash
  \mathbf{graph}~\txt{id}~\emtxt{params}~\emtxt{ins}~\emtxt{outs}~\emtxt{graphdefn}
  \gives [\txt{id} \mapsto \tau_i \rightarrow \tau_o]}

\subsection{Type expressions}
\label{sec:typing-type-expressions}

\ruleheader{\TE~\vdash \emtxt{ty} \gives \tau}

\infrule[TyCon]
{\TE(\txt{id})=\tau}
{\TE \vdash \txt{id} \gives \tau}

Type expressions, at the syntax level, are limited to type names.

% \infrule[TyCon]
% {\TE.tycons(\chi)=\seqopn{\tau}{\times}\rightarrow\tau \\
%  \forallin{i}{1}{n},~~ \TE \vdash \emtxt{ty}_i \gives \tau_i, \emptyenv}
% {\TE \vdash \chi~\tuplen{\emtxt{ty}} \gives \tau, \emptyenv}

% \infrule[TyTuple]
% {\forallin{i}{1}{n}, ~~\TE \vdash ~\emtxt{ty}_i \gives  \tau_i, \emptyenv}
% {\TE \vdash \emtxt{ty}_1 \times \ldots \times \emtxt{ty}_n \gives  \tau_1 \times \ldots \times \tau_n, \emptyenv}

% \infrule[TyFun]
% {\TE \vdash \emtxt{ty} \gives \tau, \emptyenv \andalso \vdash \emtxt{ty}' \gives \tau', \emptyenv}
% {\TE \vdash \emtxt{ty}~ \rightarrow ~\emtxt{ty}' \gives  \tau \rightarrow \tau', \emptyenv}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "hocl-lrm"
%%% End:
